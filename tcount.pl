
## this perl script enables instant counting of pattern sequences amongst
## BAM files..


#najprej converta v SAM za boljse procesiranje 

#samtools view -h -o out.sam in.bam
#mawk '{print $3,"  ",$6, "   ",$10}' ms2.sam 
# hashmap z encodanimi opcijami kako in kaj narediti!

#$ARGV[0]



# input parametri za ta program bodo npr. velikost regije, ime markerja, output fajl.
# input je identifier regija ngs.sam

my $ident = $ARGV[0];
my $region = $ARGV[1];
my $file = $ARGV[2];
#my $Rof = $ARGV[3]; #region outfile
#my $Sof = $ARGV[4]; #sequence outfile

#print ($ident."\n");

print ("Beginning processing> ".$region." ".$file."\n");

#open(my $fhR, '>', $Rof); #region outfile
#open(my $fhS, '>', $Sof); #sequence outfile

# print $fhR "My first report generated by perl\n";
# print $fhS "My first report generated by perl\n";

my @frequencies;

open my $in, "<:encoding(utf8)", $file or die "$file: $!";
while (my $line = <$in>) {
    my @tempsplit = split /\t/, $line;

    # my $sequence = $tempsplit[9];
    # print ($sequence);

    if ($ident == $tempsplit[2]){
	
	if ($tempsplit[5] !~ /^S/){

	    my @bdrs = split /-/, $region;
	    (my @Ms) = $tempsplit[5] =~ /\d{1,3}M/g;
	    (my @Is) = $tempsplit[5] =~ /\d{1,3}[I]/g;
	    (my @Ds) = $tempsplit[5] =~ /\d{1,3}[D]/g;
	    (my @all) = $tempsplit[5] =~ /\d{1,3}/g;
	    
### za prvi entry pogleda, kje je glede na region. ce je pod, potem bo prvemu pristet drugi, dokler ni nad prvo region. Pogledamo koliko nad region je, pristejemo to k dolzini	    
	    
	    my $Msum = 0;
	    my $baseLen = 0;
	    my $insertion = 0;
	    my $deletion = 0;
	    foreach $entry (@all){
		foreach $match (@Ms){
		    if ($entry == $match){
			print($entry." ".$match."\n");
			$Msum += $match;
			#print($Msum."\n");
			if ($bdrs[0] < $Msum && $bdrs[1] > $Msum){
			    print ("lower bound: ".$bdrs[0]." ".$Msum."\n");
			    $baseLen += ($Msum - $bdrs[0]);
			}elsif ($Msum < $bdrs[1] && $Msum > $bdrs[0]){
			    print ("MIddle bound: ".$bdrs[1]." ".$Msum."\n");
			    $baseLen += ($match-$bdrs[0]);
			}elsif ($Msum > $bdrs[1]){
			    print ("Higher bound..\n");
			    $baseLen = ($bdrs[1] - ($bdrs[0]));
			}		   
		    }
		    
		}	   
		# 	print $entry." ";
		# print ($bdrs[0]."  ".$bdrs[1]."\n");
	    }
	    #print ("\n base length: ".$baseLen."\n");
	    If ($Msum >= $bdrs[1]){
		print ("....BEG....\n");
		print ($tempsplit[5]."\n");
		for $sig (@Is){
		    $sig =~ s/[A-Z]+//;
		    print ($sig."iiiiii\n");
		    $baseLen += $sig;
		}
		for $dig (@Ds){
		    $dig =~ s/[A-Z]+//;
		    print ($dig."ddddd\n");
		    $baseLen -= $dig;
		}
		#push @frequencies, $baseLen;
		print ("\n base length: ".$baseLen."\n");
		print ("Match sum: ".$Msum."\n");	
		print ("....END....\n");    
	    }	    
	}
    }
}

close $in;
#close $fhR;
#close $fhS;

